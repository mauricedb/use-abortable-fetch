{"version":3,"file":"index.modern.js","sources":["../src/index.ts","../src/fetchData.ts","../src/isJSON.ts"],"sourcesContent":["import { useState, useEffect, useLayoutEffect, useRef } from 'react';\r\n\r\nimport { FetchState, AbortableFetchResult } from './types';\r\nimport fetchData from './fetchData';\r\n\r\nconst useAbortableFetch = <T>(\r\n  url: string | null,\r\n  init?: RequestInit\r\n): AbortableFetchResult<T> => {\r\n  const [state, setState] = useState<FetchState<T>>({\r\n    data: null,\r\n    loading: 0,\r\n    error: null,\r\n    controller: null\r\n  });\r\n\r\n  const isMounted = useRef(false);\r\n  useLayoutEffect((): (() => void) => {\r\n    isMounted.current = true;\r\n    return (): void => {\r\n      isMounted.current = false;\r\n    };\r\n  }, []);\r\n\r\n  useEffect((): (() => void) => {\r\n    const controller = new AbortController();\r\n    if (url) {\r\n      fetchData<T>(url, init, controller, (state): void => {\r\n        if (isMounted.current) {\r\n          setState(state);\r\n        }\r\n      });\r\n    }\r\n\r\n    return (): void => controller.abort();\r\n  }, [init, url]);\r\n\r\n  return {\r\n    data: state.data,\r\n    loading: !!state.loading,\r\n    error: state.error,\r\n    abort: (): null | void => state.controller && state.controller.abort()\r\n  };\r\n};\r\n\r\nexport default useAbortableFetch;\r\n","import { Dispatch, SetStateAction } from 'react';\r\n\r\nimport { FetchState } from './types';\r\nimport isJSON from './isJSON';\r\n\r\nconst fetchData = async <T>(\r\n  url: string,\r\n  init: RequestInit = {},\r\n  controller: AbortController,\r\n  setState: Dispatch<SetStateAction<FetchState<T>>>\r\n): Promise<void> => {\r\n  const actualInit: RequestInit = { ...init, signal: controller.signal };\r\n\r\n  let rsp: Response | null = null;\r\n  try {\r\n    setState(\r\n      (oldState: FetchState<T>): FetchState<T> => ({\r\n        data: null,\r\n        loading: oldState.loading + 1,\r\n        error: null,\r\n        controller\r\n      })\r\n    );\r\n\r\n    rsp = await fetch(url, actualInit);\r\n    const contentTypeHeader = rsp.headers.get('content-type');\r\n\r\n    if (contentTypeHeader) {\r\n      let data: T | string | null = null;\r\n\r\n      if (isJSON(contentTypeHeader)) {\r\n        data = await rsp.json();\r\n      } else {\r\n        data = await rsp.text();\r\n      }\r\n      setState(\r\n        (oldState: FetchState<T>): FetchState<T> => ({\r\n          ...oldState,\r\n          data,\r\n          loading: oldState.loading - 1\r\n        })\r\n      );\r\n    } else {\r\n      setState(\r\n        (oldState: FetchState<T>): FetchState<T> => ({\r\n          ...oldState,\r\n          loading: oldState.loading - 1\r\n        })\r\n      );\r\n    }\r\n\r\n    if (!rsp.ok) {\r\n      const err: any = new Error(rsp.statusText);\r\n      err.status = rsp.status;\r\n      throw err;\r\n    }\r\n  } catch (e) {\r\n    const err: Error = e;\r\n\r\n    const error = err.name !== 'AbortError' ? err : null;\r\n\r\n    setState(\r\n      (oldState: FetchState<T>): FetchState<T> => ({\r\n        ...oldState,\r\n        error,\r\n        // Only decrease the loading counter if there is no repsonse\r\n        loading: rsp ? oldState.loading : oldState.loading - 1\r\n      })\r\n    );\r\n  }\r\n};\r\n\r\nexport default fetchData;\r\n","import mediaTyper from 'media-typer';\r\nimport contentType from 'content-type';\r\n\r\nexport default function isJSON(\r\n  contentTypeHeader: string | null | undefined\r\n): boolean {\r\n  if (contentTypeHeader) {\r\n    const ct = contentType.parse(contentTypeHeader);\r\n\r\n    const mediaType = mediaTyper.parse(ct.type);\r\n\r\n    if (mediaType.subtype === 'json') {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.suffix === 'json') {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.suffix && /\\bjson\\b/i.test(mediaType.suffix)) {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.subtype && /\\bjson\\b/i.test(mediaType.subtype)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n"],"names":["url","init","state","setState","useState","data","loading","error","controller","isMounted","useRef","useLayoutEffect","current","useEffect","AbortController","async","actualInit","signal","rsp","oldState","fetch","contentTypeHeader","headers","get","ct","contentType","parse","mediaType","mediaTyper","type","subtype","suffix","test","isJSON","json","text","ok","err","Error","statusText","status","e","name","fetchData","abort"],"mappings":"qWAK0B,CACxBA,EACAC,KAEA,MAAOC,EAAOC,GAAYC,EAAwB,CAChDC,KAAM,KACNC,QAAS,EACTC,MAAO,KACPC,WAAY,OAGRC,EAAYC,GAAO,GAqBzB,OApBAC,EAAgB,KACdF,EAAUG,SAAU,EACb,KACLH,EAAUG,SAAU,IAErB,IAEHC,EAAU,KACR,MAAML,EAAa,IAAIM,gBASvB,OARId,GCrBUe,OAChBf,EACAC,EAAoB,GACpBO,EACAL,KAEA,MAAMa,OAA+Bf,GAAMgB,OAAQT,EAAWS,SAE9D,IAAIC,EAAuB,KAC3B,IACEf,EACGgB,KACCd,KAAM,KACNC,QAASa,EAASb,QAAU,EAC5BC,MAAO,KACPC,WAAAA,KAIJU,QAAYE,MAAMpB,EAAKgB,GACvB,MAAMK,EAAoBH,EAAII,QAAQC,IAAI,gBAE1C,GAAIF,EAAmB,CACrB,IAAIhB,EAA0B,KAK5BA,WC7BNgB,GAEA,GAAIA,EAAmB,CACrB,MAAMG,EAAKC,EAAYC,MAAML,GAEvBM,EAAYC,EAAWF,MAAMF,EAAGK,MAEtC,GAA0B,SAAtBF,EAAUG,QACZ,SAGF,GAAyB,SAArBH,EAAUI,OACZ,SAGF,GAAIJ,EAAUI,QAAU,YAAYC,KAAKL,EAAUI,QACjD,SAGF,GAAIJ,EAAUG,SAAW,YAAYE,KAAKL,EAAUG,SAClD,SAGJ,SDGQG,CAAOZ,SACIH,EAAIgB,aAEJhB,EAAIiB,OAEnBhC,EACGgB,QACIA,GACHd,KAAAA,EACAC,QAASa,EAASb,QAAU,UAIhCH,EACGgB,QACIA,GACHb,QAASa,EAASb,QAAU,KAKlC,IAAKY,EAAIkB,GAAI,CACX,MAAMC,EAAW,IAAIC,MAAMpB,EAAIqB,YAE/B,MADAF,EAAIG,OAAStB,EAAIsB,OACXH,GAER,MAAOI,GACP,MAAMJ,EAAaI,EAEblC,EAAqB,eAAb8B,EAAIK,KAAwBL,EAAM,KAEhDlC,EACGgB,QACIA,GACHZ,MAAAA,EAEAD,QAASY,EAAMC,EAASb,QAAUa,EAASb,QAAU,ODvCvDqC,CAAa3C,EAAKC,EAAMO,EAAaN,IAC/BO,EAAUG,SACZT,EAASD,KAKR,IAAYM,EAAWoC,SAC7B,CAAC3C,EAAMD,IAEH,CACLK,KAAMH,EAAMG,KACZC,UAAWJ,EAAMI,QACjBC,MAAOL,EAAMK,MACbqC,MAAO,IAAmB1C,EAAMM,YAAcN,EAAMM,WAAWoC"}